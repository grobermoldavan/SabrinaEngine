#version 450

layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout (constant_id = 0) const uint CHUNK_BOUNDS_X = 8;
layout (constant_id = 1) const uint CHUNK_BOUNDS_Y = 8;
layout (constant_id = 2) const uint CHUNK_BOUNDS_Z = 8;

layout (set = 0, binding = 0) uniform FrameData
{
    mat4 viewProjection;
    float time;
    float isoLevel;
};

//
//  Grid values are stored as follows :
//
//    y ^
//      |
//      |  / z
//      | /
//      |/
//      +----------> x
//  0,0,0
//

layout (set = 1, binding = 0) readonly buffer ChunkGrid
{
    float gridValues[];
};

struct Vertex
{
    vec4 position;
    vec4 normal;
};

layout (set = 1, binding = 1) buffer ChunkGeometry
{
    Vertex geometry[];
    // One cube is 8 triangles - 8 * 3 vertices.
    // Full chunk consists of (CHUNK_BOUNDS_X - 1) * (CHUNK_BOUNDS_Y - 1) * (CHUNK_BOUNDS_Z - 1) * 8 * 3 vertices.
};

layout (set = 1, binding = 1) readonly buffer EdgeTable
{
    int edgeTable[];
};

layout (set = 1, binding = 2) readonly buffer TriangleTable
{
    int triangleTable[];
};

vec3 vertex_interpolate(float isoLevel, vec3 p1, vec3 p2, float valP1, float valP2)
{
    float t;
    if (valP1 < valP2)
        t = (isoLevel - valP1) / (valP2 - valP1);
    else
        t = (isoLevel - valP2) / (valP1 - valP2);
    return mix(p1, p2, t);
}

uint map_3d_index_to_1d(uvec3 index)
{
    return index.x + index.y * CHUNK_BOUNDS_X + index.z * CHUNK_BOUNDS_X * CHUNK_BOUNDS_Y;
}

void main()
{
    const uint x = gl_GlobalInvocationID.x;
    const uint y = gl_GlobalInvocationID.y;
    const uint z = gl_GlobalInvocationID.z;
    if(x >= (CHUNK_BOUNDS_X - 1) || y >= (CHUNK_BOUNDS_Y - 1) || z >= (CHUNK_BOUNDS_Z - 1))
        return;

    const uvec3 index3d0 = uvec3(x    , y    , z    );
    const uvec3 index3d1 = uvec3(x + 1, y    , z    );
    const uvec3 index3d2 = uvec3(x + 1, y    , z + 1);
    const uvec3 index3d3 = uvec3(x    , y    , z + 1);
    const uvec3 index3d4 = uvec3(x    , y + 1, z    );
    const uvec3 index3d5 = uvec3(x + 1, y + 1, z    );
    const uvec3 index3d6 = uvec3(x + 1, y + 1, z + 1);
    const uvec3 index3d7 = uvec3(x    , y + 1, z + 1);

    const vec3 position0 = vec3(index3d0);
    const vec3 position1 = vec3(index3d1);
    const vec3 position2 = vec3(index3d2);
    const vec3 position3 = vec3(index3d3);
    const vec3 position4 = vec3(index3d4);
    const vec3 position5 = vec3(index3d5);
    const vec3 position6 = vec3(index3d6);
    const vec3 position7 = vec3(index3d7);

    const uint index0 = map_3d_index_to_1d(index3d0);
    const uint index1 = map_3d_index_to_1d(index3d1);
    const uint index2 = map_3d_index_to_1d(index3d2);
    const uint index3 = map_3d_index_to_1d(index3d3);
    const uint index4 = map_3d_index_to_1d(index3d4);
    const uint index5 = map_3d_index_to_1d(index3d5);
    const uint index6 = map_3d_index_to_1d(index3d6);
    const uint index7 = map_3d_index_to_1d(index3d7);

    int cubeindex = 0;
    if (gridValues[index0] < isoLevel) cubeindex |= 1;
    if (gridValues[index1] < isoLevel) cubeindex |= 2;
    if (gridValues[index2] < isoLevel) cubeindex |= 4;
    if (gridValues[index3] < isoLevel) cubeindex |= 8;
    if (gridValues[index4] < isoLevel) cubeindex |= 16;
    if (gridValues[index5] < isoLevel) cubeindex |= 32;
    if (gridValues[index6] < isoLevel) cubeindex |= 64;
    if (gridValues[index7] < isoLevel) cubeindex |= 128;

    /* Cube is entirely in/out of the surface */
    if (edgeTable[cubeindex] == 0)
        return;

    vec3 vertList[12];

    /* Find the vertices where the surface intersects the cube */
    if ((edgeTable[cubeindex] & 1) != 0)    vertList[0] = vertex_interpolate(isoLevel, position0, position1, gridValues[index0], gridValues[index1]);
    if ((edgeTable[cubeindex] & 2) != 0)    vertList[1] = vertex_interpolate(isoLevel, position1, position2, gridValues[index1], gridValues[index2]);
    if ((edgeTable[cubeindex] & 4) != 0)    vertList[2] = vertex_interpolate(isoLevel, position2, position3, gridValues[index2], gridValues[index3]);
    if ((edgeTable[cubeindex] & 8) != 0)    vertList[3] = vertex_interpolate(isoLevel, position3, position0, gridValues[index3], gridValues[index0]);
    if ((edgeTable[cubeindex] & 16) != 0)   vertList[4] = vertex_interpolate(isoLevel, position4, position5, gridValues[index4], gridValues[index5]);
    if ((edgeTable[cubeindex] & 32) != 0)   vertList[5] = vertex_interpolate(isoLevel, position5, position6, gridValues[index5], gridValues[index6]);
    if ((edgeTable[cubeindex] & 64) != 0)   vertList[6] = vertex_interpolate(isoLevel, position6, position7, gridValues[index6], gridValues[index7]);
    if ((edgeTable[cubeindex] & 128) != 0)  vertList[7] = vertex_interpolate(isoLevel, position7, position4, gridValues[index7], gridValues[index4]);
    if ((edgeTable[cubeindex] & 256) != 0)  vertList[8] = vertex_interpolate(isoLevel, position0, position4, gridValues[index0], gridValues[index4]);
    if ((edgeTable[cubeindex] & 512) != 0)  vertList[9] = vertex_interpolate(isoLevel, position1, position5, gridValues[index1], gridValues[index5]);
    if ((edgeTable[cubeindex] & 1024) != 0) vertList[10] = vertex_interpolate(isoLevel, position2, position6, gridValues[index2], gridValues[index6]);
    if ((edgeTable[cubeindex] & 2048) != 0) vertList[11] = vertex_interpolate(isoLevel, position3, position7, gridValues[index3], gridValues[index7]);

    /* Create the triangle */
    const uint geometryArrayInitialOffset = index0 * 8 * 3;
    int ntriang = 0;
    for (int i = 0; i < 16; i += 3)
    {
        if (triangleTable[16 * cubeindex + i] != -1)
        {
            geometry[geometryArrayInitialOffset + ntriang * 3 + 0].position = vec4(vertList[triangleTable[16 * cubeindex + i   ]], 1);
            geometry[geometryArrayInitialOffset + ntriang * 3 + 1].position = vec4(vertList[triangleTable[16 * cubeindex + i+ 1]], 1);
            geometry[geometryArrayInitialOffset + ntriang * 3 + 2].position = vec4(vertList[triangleTable[16 * cubeindex + i+ 2]], 1);
            ntriang++;
        }
        else
        {
            geometry[geometryArrayInitialOffset + ntriang * 3 + 0].position = vec4(0);
            geometry[geometryArrayInitialOffset + ntriang * 3 + 1].position = vec4(0);
            geometry[geometryArrayInitialOffset + ntriang * 3 + 2].position = vec4(0);
        }
    }
}
